Le projet **Philosophers** de l'Ã©cole 42 est une introduction aux concepts
de **concurrence** et de **synchronisation** dans la programmation en C,
en utilisant des **threads** et des **mutexes**.

---

### RÃ©sumÃ© des consignes

Le projet **Philosophers** simule un problÃ¨me classique d'informatique : le **problÃ¨me des philosophes dineurs**.
Voici les points clÃ©s :

1. **Contexte** :
   - Des philosophes (nombre donnÃ© en argument) sont assis autour d'une table ronde avec un bol de spaghettis au centre.
   - Il y a autant de fourchettes que de philosophes, une entre chaque paire de philosophes.
   - Les philosophes alternent entre **manger**, **penser** et **dormir**.
   Pour manger, un philosophe doit prendre **deux fourchettes** (celle Ã  sa gauche et celle Ã  sa droite).

2. **Arguments du programme** :
   - `number_of_philosophers` : Nombre de philosophes (et de fourchettes).
   - `time_to_die` : Temps (en ms) avant quâ€™un philosophe ne meure sâ€™il nâ€™a pas mangÃ©.
   - `time_to_eat` : Temps (en ms) quâ€™un philosophe passe Ã  manger (en tenant deux fourchettes).
   - `time_to_sleep` : Temps (en ms) quâ€™un philosophe passe Ã  dormir.
   - `[number_of_times_each_philosopher_must_eat]` (optionnel) : Nb de repas nÃ©cessaires pour arrÃªter la simulation.

3. **RÃ¨gles** :
   - Chaque philosophe est un **thread** distinct.
   - Les fourchettes sont partagÃ©es et protÃ©gÃ©es par des **mutexes** pour Ã©viter les conflits dâ€™accÃ¨s.
   - Les philosophes ne communiquent pas entre eux et ne savent pas si un autre est sur le point de mourir.
   - La simulation sâ€™arrÃªte si un philosophe meurt (de faim)
   	 ou si tous ont mangÃ© le nombre de repas requis (si spÃ©cifiÃ©).
   - Les changements dâ€™Ã©tat (prend une fourchette, mange, dort, pense, meurt)
   	 doivent Ãªtre affichÃ©s avec un **timestamp** (en ms) et sans chevauchement de messages.
   - La mort dâ€™un philosophe doit Ãªtre annoncÃ©e dans les **10 ms** suivant son dÃ©cÃ¨s.
   - Pas de **data races** (accÃ¨s concurrents non protÃ©gÃ©s aux ressources partagÃ©es).

4. **Contraintes techniques** :
   - Langage : C, conforme Ã  la Norme 42.
   - Pas de variables globales.
   - Gestion propre de la mÃ©moire (pas de fuites).
   - Utilisation des fonctions autorisÃ©es :
   	`memset`, `printf`, `malloc`, `free`, `write`, `usleep`, `gettimeofday`, `pthread_create`,
	`pthread_detach`, `pthread_join`, `pthread_mutex_init`, `pthread_mutex_destroy`, `pthread_mutex_lock`,
	`pthread_mutex_unlock`.
   - Makefile avec rÃ¨gles standard (`NAME`, `all`, `clean`, `fclean`, `re`).

5. **Objectif** :
   - Ã‰crire un programme (`philo`) qui simule les philosophes en Ã©vitant quâ€™ils meurent de faim,
   	 tout en gÃ©rant la concurrence pour les fourchettes.

---

### Nouvelles notions par rapport aux projets prÃ©cÃ©dents

Les projets prÃ©cÃ©dents (libft, born2beroot, ft_printf, get_next_line, push_swap, so_long, minitalk)
ont introduit Ã  des concepts comme :
	- la manipulation de mÃ©moire
	- les entrÃ©es/sorties
	- les structures de donnÃ©es
	- les algorithmes
	- la communication inter-processus.

**Philosophers** introduit des notions de **programmation concurrente** qui sont nouvelles.
Voici une comparaison et les nouveautÃ©s :

#### 1. **Programmation concurrente avec threads**

   - **Projets prÃ©cÃ©dents** :
     - Aucun projet nâ€™utilisait de **threads**. Les programmes Ã©taient **sÃ©quentiels** (une seule tÃ¢che Ã  la fois).
     - Dans **minitalk**, tu as utilisÃ© des **processus** (via `fork` ou signaux),
	   mais les processus sont indÃ©pendants et ne partagent pas la mÃ©moire.

   - **Philosophers** :
     - Chaque philosophe est un **thread** (crÃ©Ã© avec `pthread_create`).
	   Les threads sâ€™exÃ©cutent **simultanÃ©ment** dans le mÃªme processus et partagent la mÃªme mÃ©moire.
     - Tu dois gÃ©rer la **concurrence** : plusieurs threads accÃ¨dent aux mÃªmes ressources
	   (fourchettes, logs, Ã©tat de la simulation).
     - Nouvelles fonctions utilisÃ©es :
=>     - `pthread_create` : CrÃ©e un thread.
=>     - `pthread_join` : Attend la fin dâ€™un thread.
=>     - `pthread_detach` : Permet Ã  un thread de se libÃ©rer automatiquement Ã  la fin.

     - **DÃ©fi** : Synchroniser les threads pour Ã©viter des comportements imprÃ©visibles
		(ex. : plusieurs philosophes prenant la mÃªme fourchette).

#### 2. **Synchronisation avec mutexes**

   - **Projets prÃ©cÃ©dents** :
     - Aucun projet nâ€™a requis de gÃ©rer des **ressources partagÃ©es** entre plusieurs entitÃ©s exÃ©cutÃ©es simultanÃ©ment.
     - Les projets comme **push_swap** ou **so_long** Ã©taient mono-thread et nâ€™avaient pas besoin de synchronisation.

   - **Philosophers** :
     - Les fourchettes sont des ressources partagÃ©es.
	   Pour Ã©viter que plusieurs philosophes prennent la mÃªme fourchette en mÃªme temps,
=>	   tu dois utiliser des **mutexes** (verrous).
=>   - Un **mutex** (mutual exclusion) garantit quâ€™un seul thread peut accÃ©der Ã  une ressource Ã  la fois.
     - Nouvelles fonctions :
=>     - `pthread_mutex_init` : Initialise un mutex.
=>     - `pthread_mutex_lock` : Verrouille un mutex (attend si dÃ©jÃ  verrouillÃ©).
=>     - `pthread_mutex_unlock` : DÃ©verrouille un mutex.
=>     - `pthread_mutex_destroy` : LibÃ¨re un mutex.

     - **DÃ©fi** : ProtÃ©ger chaque fourchette avec un mutex et gÃ©rer lâ€™affichage des logs pour Ã©viter les chevauchements
	  (ex. : plusieurs threads Ã©crivant sur `stdout` simultanÃ©ment).

#### 3. **Gestion du temps et des temporisations**

   - **Projets prÃ©cÃ©dents** :
     - Les projets comme **get_next_line** ou **ft_printf** nâ€™avaient pas de contraintes temporelles explicites.
     - **minitalk** utilisait des signaux, mais sans gestion prÃ©cise du temps en millisecondes.

   - **Philosophers** :
     - Tu dois gÃ©rer des temporisations prÃ©cises (en millisecondes) pour :
       - VÃ©rifier si un philosophe dÃ©passe `time_to_die` sans manger.
       - Simuler les durÃ©es de `time_to_eat` et `time_to_sleep`.
=>   - Nouvelle fonction : `gettimeofday` pour obtenir un timestamp prÃ©cis en millisecondes.

     - **DÃ©fi** : Calculer les intervalles de temps correctement et arrÃªter la simulation dÃ¨s quâ€™un philosophe meurt,
	   tout en respectant la contrainte des 10 ms pour afficher la mort.

#### 4. **Ã‰viter les data races**
   - **Projets prÃ©cÃ©dents** :
     - Aucun projet nâ€™avait de risque de **data races**, car ils Ã©taient mono-thread ou utilisaient des processus indÃ©pendants.
   - **Philosophers** :
     - Une **data race** survient quand plusieurs threads accÃ¨dent Ã  une ressource partagÃ©e (ex. : une variable ou une fourchette) sans synchronisation, entraÃ®nant des comportements imprÃ©visibles.
     - Tu dois utiliser des mutexes pour protÃ©ger :
       - Lâ€™accÃ¨s aux fourchettes.
       - Lâ€™affichage des messages (pour Ã©viter que les logs se mÃ©langent).
       - Les variables partagÃ©es (ex. : Ã©tat de la simulation ou compteur de repas).
     - **DÃ©fi** : Identifier toutes les ressources partagÃ©es et les protÃ©ger correctement.

#### 5. **ProblÃ¨me des philosophes dineurs**
   - **Projets prÃ©cÃ©dents** :
     - Les projets comme **push_swap** ou **so_long** impliquaient des algorithmes ou des simulations, mais sans concurrence.
   - **Philosophers** :
     - Ce projet est une implÃ©mentation du **problÃ¨me des philosophes dineurs**, un problÃ¨me classique en informatique pour Ã©tudier la synchronisation et Ã©viter :
       - **Deadlock** : Tous les philosophes prennent une fourchette et attendent lâ€™autre, bloquant la simulation.
       - **Starvation** : Un philosophe ne peut jamais manger (ex. : bloquÃ© par ses voisins).
     - **DÃ©fi** : Concevoir une stratÃ©gie pour que les philosophes mangent sans mourir, par exemple en imposant un ordre pour prendre les fourchettes (ex. : toujours prendre la fourchette de gauche dâ€™abord) ou en limitant le nombre de philosophes mangeant simultanÃ©ment.

#### 6. **Gestion des threads et terminaison propre**
   - **Projets prÃ©cÃ©dents** :
     - Les projets se terminaient simplement en libÃ©rant la mÃ©moire et en quittant.
   - **Philosophers** :
     - Tu dois gÃ©rer la **crÃ©ation**, lâ€™**exÃ©cution** et la **terminaison** de plusieurs threads.
     - Ã€ la fin de la simulation (mort dâ€™un philosophe ou repas complets), tu dois :
       - ArrÃªter tous les threads proprement (souvent via `pthread_join` ou `pthread_detach`).
       - LibÃ©rer les mutexes avec `pthread_mutex_destroy`.
       - LibÃ©rer toute mÃ©moire allouÃ©e.
     - **DÃ©fi** : Sâ€™assurer que la simulation sâ€™arrÃªte immÃ©diatement aprÃ¨s une mort et que toutes les ressources sont libÃ©rÃ©es.

---

### Conseils pour aborder le projet

1. **Comprendre la structure** :
   - CrÃ©e une structure pour stocker les donnÃ©es globales (arguments, mutexes, Ã©tat de la simulation).
   - CrÃ©e une structure par philosophe (avec son numÃ©ro, ses fourchettes, son dernier repas, etc.).

2. **DÃ©couper le problÃ¨me** :
   - **Parsing** : VÃ©rifie et stocke les arguments.
   - **Initialisation** : CrÃ©e les mutexes pour les fourchettes et les logs, alloue les philosophes.
   - **Simulation** :
     - Lance un thread par philosophe avec une routine (manger, dormir, penser).
     - Lance un thread ou une boucle pour surveiller les morts (vÃ©rifier `time_to_die`).
   - **Terminaison** : ArrÃªte les threads, libÃ¨re les mutexes et la mÃ©moire.

3. **GÃ©rer la synchronisation** :
   - Utilise un mutex par fourchette.
   - ProtÃ¨ge lâ€™affichage des logs avec un mutex global.
   - VÃ©rifie rÃ©guliÃ¨rement si un philosophe est mort dans un thread de supervision.

4. **Ã‰viter les problÃ¨mes classiques** :
   - **Deadlock** : Fais prendre les fourchettes dans un ordre cohÃ©rent (ex. : fourchette avec lâ€™index le plus bas en premier).
   - **Starvation** : Assure que tous les philosophes ont une chance de manger (ex. : alterne les philosophes pairs/impairs).
   - **PrÃ©cision temporelle** : Utilise `usleep` avec des boucles pour des temporisations prÃ©cises.

5. **Tester rigoureusement** :
   - Teste avec diffÃ©rents nombres de philosophes (1, 2, 5, 100).
   - Teste des cas limites (ex. : `time_to_die` trÃ¨s court).
   - Utilise des outils comme `valgrind` pour vÃ©rifier les fuites mÃ©moire et `helgrind` pour dÃ©tecter les data races.

---

### Exemple de flux pour un philosophe

1. **DÃ©marre** : VÃ©rifie si la simulation est active.
2. **Prend les fourchettes** :
   - Verrouille le mutex de la fourchette gauche.
   - Affiche Â« X has taken a fork Â».
   - Verrouille le mutex de la fourchette droite.
   - Affiche Â« X has taken a fork Â».
3. **Mange** :
   - Affiche Â« X is eating Â».
   - Met Ã  jour le timestamp du dernier repas.
   - Attend `time_to_eat` millisecondes.
4. **Repose les fourchettes** :
   - DÃ©verrouille les mutexes des fourchettes.
5. **Dort** :
   - Affiche Â« X is sleeping Â».
   - Attend `time_to_sleep` millisecondes.
6. **Pense** :
   - Affiche Â« X is thinking Â».
7. **Recommence** jusquâ€™Ã  la fin de la simulation.

---

### Ressources utiles

- **Documentation POSIX threads** : Lis les pages man de `pthread_create`, `pthread_mutex_lock`, etc.
- **ProblÃ¨me des philosophes dineurs** : Recherche des explications sur ce problÃ¨me classique (ex. : sur Wikipedia ou des cours dâ€™informatique).
- **Outils de dÃ©bogage** :
  - `valgrind --tool=helgrind` pour dÃ©tecter les data races.
  - `strace` pour suivre les appels systÃ¨me.
- **Testeurs 42** : Cherche des testeurs open-source pour Philosophers sur GitHub.

---

Si tu as des questions spÃ©cifiques sur une partie du projet (parsing, threads, mutexes, etc.), nâ€™hÃ©site pas Ã  demander ! Bonne chance pour ton cercle et ce projet, câ€™est un beau dÃ©fi qui te fera progresser en concurrence. ğŸ˜Š